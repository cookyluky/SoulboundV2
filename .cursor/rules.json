{
  "rules": [
    {
      "description": "Tech Stack & Versions - Enforce specific Unity engine and package versions",
      "globs": ["**/*.cs", "**/*.md", "**/manifest.json", "**/packages-lock.json"],
      "alwaysApply": true,
      "content": "TECH STACK REQUIREMENTS:\n\n- Unity Engine: 2024.3 LTS (or latest LTS if newer)\n- Rendering Pipeline: Universal Render Pipeline (URP) v17.x or compatible\n- Build Backend: IL2CPP for production builds\n- C# Language Version: C# 10\n- .NET Target: .NET Standard 2.1\n\nPACKAGE DEPENDENCIES:\n- Unity UI Toolkit (UIElements) - for modern UI development\n- Unity Input System - for cross-platform input handling\n- Unity Addressables - for asset management (when needed)\n- Firebase SDK v9.0+ - for backend services (when implemented)\n- FMOD Unity Integration v3.0+ - for advanced audio (when implemented)\n\nWhen suggesting new packages or dependencies:\n1. Always specify exact version numbers\n2. Verify compatibility with Unity 2024.3 LTS\n3. Consider build size and performance impact\n4. Update this rule if new core packages are added"
    },
    {
      "description": "Project Structure - Enforce folder organization and approval process for new directories",
      "globs": ["**/*"],
      "alwaysApply": true, 
      "content": "PROJECT STRUCTURE REQUIREMENTS:\n\nFOLDER PURPOSES:\n- Assets/Scripts/ - All C# scripts organized by functionality\n  - Systems/ - Core game systems (Combat, Progression, Exploration)\n  - Characters/ - Character-specific scripts (Aric, Elysia, Kaelen)\n  - Items/ - Item and inventory related scripts\n  - UI/ - All user interface scripts\n- Assets/Art/ - Visual assets organized by type\n  - Characters/ - Character models, textures, animations\n  - Environments/ - Environment assets, props, materials\n- Assets/Audio/ - Sound assets\n  - Music/ - Background music and ambient sounds\n  - SFX/ - Sound effects and UI sounds\n- Assets/Prefabs/ - Reusable Unity prefabs\n- Assets/Scenes/ - Unity scene files\n- Documentation/ - Project documentation\n  - Tasks/ - Task management and project planning\n  - Design/ - Game design documents\n  - Tech/ - Technical specifications\n  - Art/ - Art guidelines and style guides\n  - TasksMDC/ - Markdown Component documentation\n- .cursor/ - AI assistant configuration\n\nRULES:\n1. All new code must follow this structure\n2. New top-level folders require explicit approval\n3. Scripts must be placed in appropriate subfolders\n4. Keep related files grouped together\n5. Use descriptive folder names that indicate purpose"
    },
    {
      "description": "Naming Conventions - Enforce consistent file and class naming across the project",
      "globs": ["**/*.cs", "**/*.prefab", "**/*.unity", "**/*.md"],
      "alwaysApply": true,
      "content": "NAMING CONVENTION REQUIREMENTS:\n\nC# FILES & CLASSES:\n- Use PascalCase for all class names\n- File names must match class names exactly\n- One class per file (except for small helper classes)\n- Examples: GameManager.cs, PlayerController.cs, CombatSystem.cs\n\nFOLDERS:\n- Use PascalCase for script folders: Scripts/Systems/, Scripts/Characters/\n- Use PascalCase or kebab-case for asset folders: Art/Characters/, Audio/Music/\n- Keep folder names concise but descriptive\n\nUNITY ASSETS:\n- Prefabs: Use format 'Prefab_<ObjectName>.prefab'\n  - Examples: Prefab_Player.prefab, Prefab_HealthBar.prefab\n- Scenes: Use format 'Scene_<Name>.unity'\n  - Examples: Scene_MainMenu.unity, Scene_Level01.unity\n- Materials: Use format 'Mat_<Name>.mat'\n- Textures: Use format 'Tex_<Name>.<ext>'\n\nVARIABLES & METHODS:\n- Public fields/properties: PascalCase\n- Private fields: camelCase with underscore prefix (_privateField)\n- Methods: PascalCase\n- Constants: UPPER_SNAKE_CASE\n- Events: PascalCase with 'On' prefix (OnPlayerDeath)\n\nDOCUMENTATION:\n- Markdown files: Use descriptive names in PascalCase\n- Examples: TechSpecs.md, ArtGuidelines.md"
    },
    {
      "description": "Coding Style & Language Preferences - Enforce consistent C# and documentation formatting",
      "globs": ["**/*.cs", "**/*.md"],
      "alwaysApply": true,
      "content": "CODING STYLE REQUIREMENTS:\n\nC# FORMATTING:\n- Indentation: 4 spaces (no tabs)\n- Curly braces: Always on new line (Allman style)\n- Access modifiers: Always explicit (public, private, protected)\n- No #region directives - use clear class organization instead\n- Line length: Prefer 120 characters max\n- File encoding: UTF-8 without BOM\n\nC# STRUCTURE:\n- Order: Fields, Properties, Events, Methods\n- Group related members together\n- Use meaningful variable names\n- Add XML documentation for public APIs\n- Prefer composition over inheritance\n- Use Unity's [SerializeField] for inspector fields\n\nCODE EXAMPLES:\npublic class ExampleClass : MonoBehaviour\n{\n    [SerializeField] private float _moveSpeed = 5f;\n    \n    public float MoveSpeed\n    {\n        get => _moveSpeed;\n        set => _moveSpeed = value;\n    }\n    \n    public event Action<float> OnSpeedChanged;\n    \n    private void Start()\n    {\n        InitializeComponent();\n    }\n    \n    /// <summary>\n    /// Initializes the component with default values\n    /// </summary>\n    private void InitializeComponent()\n    {\n        // Implementation here\n    }\n}\n\nMARKDOWN FORMATTING:\n- Use English language\n- Write concisely and clearly\n- Use ## for main headings, ### for subheadings\n- Use bullet points for lists\n- Include code examples in fenced blocks\n- Keep tone professional but approachable"
    },
    {
      "description": "UI Coding Preferences - Enforce modern Unity UI practices and organization",
      "globs": ["**/UI/*.cs", "**/UI/**/*.cs", "**/*UI*.cs"],
      "alwaysApply": true,
      "content": "UI CODING REQUIREMENTS:\n\nUI ARCHITECTURE:\n- All UI scripts inherit from MonoBehaviour\n- Use Unity UI Toolkit (UIElements) for new UI when possible\n- Legacy UGUI only for simple components or existing systems\n- Separate UI logic from game logic\n\nFOLDER ORGANIZATION:\n- UI scripts: Assets/Scripts/UI/\n- UI prefabs: Assets/Prefabs/UI/\n- UI stylesheets: Assets/UI/Styles/ (when using UIElements)\n- UI assets: Assets/Art/UI/\n\nCODING PATTERNS:\n- Use serialized C# properties for data binding\n- Avoid GameObject.Find() and FindObjectOfType() at runtime\n- Cache UI references in Awake() or Start()\n- Use events for UI communication\n- Implement INotifyPropertyChanged for data binding when needed\n\nEXAMPLE UI SCRIPT:\npublic class HealthBar : MonoBehaviour\n{\n    [SerializeField] private Slider _healthSlider;\n    [SerializeField] private TextMeshProUGUI _healthText;\n    \n    public float MaxHealth { get; set; } = 100f;\n    public float CurrentHealth { get; private set; }\n    \n    public event Action<float> OnHealthChanged;\n    \n    private void Awake()\n    {\n        ValidateReferences();\n    }\n    \n    public void UpdateHealth(float newHealth)\n    {\n        CurrentHealth = Mathf.Clamp(newHealth, 0f, MaxHealth);\n        UpdateDisplay();\n        OnHealthChanged?.Invoke(CurrentHealth);\n    }\n    \n    private void UpdateDisplay()\n    {\n        if (_healthSlider != null)\n        {\n            _healthSlider.value = CurrentHealth / MaxHealth;\n        }\n        \n        if (_healthText != null)\n        {\n            _healthText.text = $\"{CurrentHealth:F0}/{MaxHealth:F0}\";\n        }\n    }\n    \n    private void ValidateReferences()\n    {\n        if (_healthSlider == null || _healthText == null)\n        {\n            Debug.LogError($\"Missing UI references in {gameObject.name}\");\n        }\n    }\n}\n\nUI BEST PRACTICES:\n- Always validate UI references\n- Use null-conditional operators\n- Implement proper error handling\n- Use Unity Events for inspector-assigned callbacks\n- Keep UI update methods lightweight"
    }
  ]
} 